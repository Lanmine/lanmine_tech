{
  "name": "Network Flow Summary",
  "nodes": [
    {
      "parameters": {
        "rule": {"interval": [{"field": "cronExpression", "expression": "0 9 * * *"}]}
      },
      "id": "schedule-1",
      "name": "Daily 09:00",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [200, 400]
    },
    {
      "parameters": {
        "httpMethod": "GET",
        "path": "network-summary",
        "responseMode": "lastNode",
        "options": {}
      },
      "id": "webhook-1",
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [200, 200],
      "webhookId": "network-summary"
    },
    {
      "parameters": {
        "jsCode": "// Query all ClickHouse data in one node\nconst CLICKHOUSE_URL = 'http://10.0.10.26:8123/?default_format=JSON';\n\nconst queries = {\n  totals: 'SELECT sum(Bytes) as TotalBytes, sum(Packets) as TotalPackets, uniq(SrcAddr) as UniqueSources, uniq(DstAddr) as UniqueDestinations FROM flows WHERE TimeReceived >= now() - INTERVAL 24 HOUR',\n  topSources: \"SELECT replaceRegexpOne(toString(SrcAddr), '^::ffff:', '') as SrcAddr, sum(Bytes) as TotalBytes FROM flows WHERE TimeReceived >= now() - INTERVAL 24 HOUR GROUP BY SrcAddr ORDER BY TotalBytes DESC LIMIT 10\",\n  topFlows: \"SELECT replaceRegexpOne(toString(SrcAddr), '^::ffff:', '') as SrcAddr, replaceRegexpOne(toString(DstAddr), '^::ffff:', '') as DstAddr, sum(Bytes) as TotalBytes, sum(Packets) as TotalPackets FROM flows WHERE TimeReceived >= now() - INTERVAL 24 HOUR GROUP BY SrcAddr, DstAddr ORDER BY TotalBytes DESC LIMIT 20\"\n};\n\nconst results = {};\nconst debug = {};\n\nfor (const [name, query] of Object.entries(queries)) {\n  try {\n    const response = await this.helpers.httpRequest({\n      method: 'POST',\n      url: CLICKHOUSE_URL,\n      body: query,\n      headers: { 'Content-Type': 'text/plain' },\n      timeout: 30000\n    });\n    results[name] = response;\n    debug[name] = { status: 'ok', dataCount: response?.data?.length || 0 };\n  } catch (e) {\n    debug[name] = { status: 'error', message: e.message };\n    results[name] = { data: [] };\n  }\n}\n\nreturn [{ json: { results, debug } }];"
      },
      "id": "fetch-data",
      "name": "Fetch All Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [450, 300]
    },
    {
      "parameters": {
        "jsCode": "const formatBytes = (bytes) => {\n  if (!bytes || bytes === 0) return '0 B';\n  const k = 1024;\n  const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n};\n\nconst input = $input.first()?.json || {};\nconst results = input.results || {};\nconst debug = input.debug || {};\n\nconst totals = results.totals?.data?.[0] || {};\nconst topSources = results.topSources?.data || [];\nconst topFlows = results.topFlows?.data || [];\n\nconst hasData = topFlows.length > 0 || Object.keys(totals).length > 0;\n\nif (!hasData) {\n  return [{ json: { hasData: false, summary: 'No flow data available.', debug, timestamp: new Date().toISOString() } }];\n}\n\nconst topTalkers = topSources.slice(0, 5).map(s => ({ ip: s.SrcAddr, bytes: formatBytes(parseInt(s.TotalBytes)) }));\n\nreturn [{\n  json: {\n    hasData: true,\n    totalBytes: formatBytes(parseInt(totals.TotalBytes || 0)),\n    totalPackets: parseInt(totals.TotalPackets || 0).toLocaleString(),\n    uniqueSources: parseInt(totals.UniqueSources || 0),\n    uniqueDestinations: parseInt(totals.UniqueDestinations || 0),\n    topTalkers,\n    topFlowPairs: topFlows.slice(0, 5).map(f => ({ src: f.SrcAddr, dst: f.DstAddr, bytes: formatBytes(parseInt(f.TotalBytes)) })),\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "id": "aggregate-data",
      "name": "Aggregate Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [700, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {"caseSensitive": true, "leftValue": "", "typeValidation": "strict"},
          "conditions": [{"id": "cond-1", "leftValue": "={{ $json.hasData }}", "rightValue": true, "operator": {"type": "boolean", "operation": "equals"}}],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "if-data",
      "name": "Has Data?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [900, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://10.0.20.2:11434/v1/chat/completions",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ model: 'default', messages: [{ role: 'system', content: 'You are a network analyst. Summarize network flow data in 2-3 sentences. Highlight: 1) Overall traffic volume, 2) Top talkers and what they might be (if recognizable IPs), 3) Any patterns worth noting. Be concise.' }, { role: 'user', content: 'Network flow summary for last 24h:\\n\\nTotal: ' + $json.totalBytes + ', ' + $json.totalPackets + ' packets\\nUnique: ' + $json.uniqueSources + ' src, ' + $json.uniqueDestinations + ' dst\\n\\nTop talkers:\\n' + $json.topTalkers.map(t => t.ip + ': ' + t.bytes).join('\\n') + '\\n\\nTop flows:\\n' + $json.topFlowPairs.map(f => f.src + ' -> ' + f.dst + ': ' + f.bytes).join('\\n') }], max_tokens: 200 }) }}",
        "options": {"timeout": 60000}
      },
      "id": "llm-summary",
      "name": "LLM Summary",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [1100, 200],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "const flowData = $items('Aggregate Data')[0].json;\nconst llmResponse = $input.first()?.json || {};\n\nlet summary = llmResponse.choices?.[0]?.message?.content || '';\nif (!summary) {\n  summary = `24h traffic: ${flowData.totalBytes}, ${flowData.totalPackets} packets. Top source: ${flowData.topTalkers[0]?.ip || 'N/A'} (${flowData.topTalkers[0]?.bytes || '0 B'}).`;\n}\n\nconst talkerList = flowData.topTalkers.map(t => `\\`${t.ip}\\`: ${t.bytes}`).join('\\n') || 'No data';\n\nreturn [{ json: { summary, totalBytes: flowData.totalBytes, totalPackets: flowData.totalPackets, uniqueSources: flowData.uniqueSources, uniqueDestinations: flowData.uniqueDestinations, talkerList, timestamp: flowData.timestamp } }];"
      },
      "id": "format-output",
      "name": "Format Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1300, 200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "{{DISCORD_WEBHOOK_URL}}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ embeds: [{ title: ':globe_with_meridians: Network Flow Summary', description: $json.summary, color: 3447003, fields: [{ name: 'Total Traffic', value: $json.totalBytes, inline: true }, { name: 'Packets', value: $json.totalPackets, inline: true }, { name: 'Unique IPs', value: $json.uniqueSources + ' src / ' + $json.uniqueDestinations + ' dst', inline: true }, { name: 'Top Talkers', value: $json.talkerList, inline: false }], timestamp: $json.timestamp }] }) }}",
        "options": {"timeout": 10000}
      },
      "id": "discord",
      "name": "Post to Discord",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [1500, 200]
    },
    {
      "parameters": {
        "jsCode": "const data = $items('Format Output')[0]?.json || $items('Aggregate Data')[0]?.json;\nreturn [{ json: data }];"
      },
      "id": "response",
      "name": "Webhook Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1500, 400]
    },
    {
      "parameters": {
        "jsCode": "const aggData = $items('Aggregate Data')[0]?.json || {};\nreturn [{ json: { status: 'no_data', message: 'No flow data available', debug: aggData.debug } }];"
      },
      "id": "no-data",
      "name": "No Data Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1100, 400]
    }
  ],
  "connections": {
    "Daily 09:00": {"main": [[{"node": "Fetch All Data", "type": "main", "index": 0}]]},
    "Manual Trigger": {"main": [[{"node": "Fetch All Data", "type": "main", "index": 0}]]},
    "Fetch All Data": {"main": [[{"node": "Aggregate Data", "type": "main", "index": 0}]]},
    "Aggregate Data": {"main": [[{"node": "Has Data?", "type": "main", "index": 0}]]},
    "Has Data?": {"main": [[{"node": "LLM Summary", "type": "main", "index": 0}], [{"node": "No Data Response", "type": "main", "index": 0}]]},
    "LLM Summary": {"main": [[{"node": "Format Output", "type": "main", "index": 0}], [{"node": "Format Output", "type": "main", "index": 0}]]},
    "Format Output": {"main": [[{"node": "Post to Discord", "type": "main", "index": 0}, {"node": "Webhook Response", "type": "main", "index": 0}]]}
  },
  "settings": {"executionOrder": "v1"}
}
